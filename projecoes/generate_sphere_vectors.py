#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vi:ts=4 sw=4 et

from __future__ import print_function

import sys

from math import sin, cos, radians, degrees


# The size (length, norm) of vectors generated by this script
radius = 200

# How big is the pitch/yaw for the calibration generated by this script
# What is pitch and yaw?
# http://en.wikipedia.org/wiki/Flight_dynamics_(aircraft)
pitch_window = 45
yaw_window = 45


def parse_args(args):
    global pitch_window, yaw_window

    calibration_angle = None
    i = 0
    while i < len(args):
        arg = args[i]

        if arg in ['--help', '-h', '-help', '/?']:
            print('Available parameters:')
            print('  -h,--help        Print this help')
            print('  -c,--calibrate   Print calibration vectors at a theta angle')
            print('                   Example:   -c 30')
            print('  -p,--pitch       Set the "pitch window", or how far are the calibration corners')
            print('                   Example:   -p 45')
            print('  -y,--yaw         Set the "yaw window", or how far are the calibration corners')
            print('                   Example:   -y 45')
            sys.exit(0)

        elif arg in ['--calibrate', '-c']:
            i+= 1
            value = int(args[i])
            calibration_angle = value

        elif arg in ['--pitch', '-p']:
            i+= 1
            value = int(args[i])
            pitch_window = value

        elif arg in ['--yaw', '-y']:
            i+= 1
            value = int(args[i])
            yaw_window = value

        i+= 1

    if calibration_angle is not None:
        print_calibration(value)

def print_calibration(angle):
    global pitch_window, yaw_window

    pitch = pitch_window/2
    yaw = yaw_window/2

    center_phi = 0
    offsets = [
        (+pitch, +yaw, 'topleft'),
        (+pitch, -yaw, 'topright'),
        (-pitch, -yaw, 'bottomright'),
        (-pitch, +yaw, 'bottomleft'),
    ]
    for delta_theta, delta_phi, name in offsets:
        x, y, z = spherical_to_cartesian(angle + delta_theta, center_phi + delta_phi)
        print(name)
        print('{0}\t{1}\t{2}'.format(x, y, z))
    sys.stdout.flush()

def spherical_to_cartesian(theta, phi):
    global radius

    # These are not exactly the same equations as in:
    # http://en.wikipedia.org/wiki/Spherical_coordinates

    x = radius * cos(radians(theta)) * cos(radians(phi))
    y = radius * cos(radians(theta)) * sin(radians(phi))
    z = radius * sin(radians(theta))

    x = int(round(x))
    y = int(round(y))
    z = int(round(z))

    return x, y, z

def main(args):
    parse_args(args)

    SHOULD_SLEEP = False

    for theta in range(45, -45, -2):
    #for theta in range(75, -75, -5):
        #for phi in range(0, 360, 5):
        for phi in range(-90, 90, 1):
            x, y, z = spherical_to_cartesian(theta, phi)
            print('{0}\t{1}\t{2}'.format(x, y, z))

        if SHOULD_SLEEP:
            sys.stdout.flush()
            sys.stderr.write('theta={0}\n'.format(theta))
            sys.stderr.flush()

            import time
            time.sleep(0.5)


if __name__ == "__main__":
    main(sys.argv[1:])
